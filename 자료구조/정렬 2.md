## 시간 복잡도에 따른 분류

### 1. $O(n^2)$

- 거품 정렬 (Bubble Sort)
- 선택 정렬 (Selection Sort)
- 삽입 정렬 (Insertion Sort)

### 2. $O(nlogn)$

- 병합 정렬 (Merge Sort)
- 힙 정렬 (Heap Sort)
- 퀵 정렬 (Quick Sort)
- 트리 정렬 (Tree Sort)

<br /><br /><br />

## 병합 정렬 (Merge Sort)

> 하나의 리스트를 두 개의 균등한 크기로 분할하고, 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 알고리즘
> 

### 개념

- **‘분할 정복 (Divide and Conquer)’** 알고리즘을 기반으로 정렬
- 데이터를 비교하면서 찾는 **'비교 정렬'**
- 일반적으로 절반으로 나누는 방식인 **Two-way 방식**을 사용하나 반드시 2개의 부분 리스트로 나누어야 하는 것은 아님
- 두 부분 리스트를 합쳐서 정렬할 때 각 부분 리스트의 첫 번째 원소부터 순차적으로 비교

### 과정

1. **분할 (Divide)** : 주어진 리스트를 절반으로 분할하여 부분 리스트로 나눔
2. **병합 (Merge)** : 인접한 부분 리스트끼리 정렬하여 합침
3. **정복 (Conquer)** : 순환 호출을 통한 분할, 병합

### 예시

![병합 정렬 001](https://user-images.githubusercontent.com/76759852/213846382-ad566c9a-f9ae-4481-a60c-65749a6adca9.jpeg)

→ 길이가 1이 될 때까지 분할

<br />

![병합 정렬 002](https://user-images.githubusercontent.com/76759852/213846384-ef5e10a7-c7a5-4206-af5f-57debe94bde5.jpeg)

<br />

1. 3과 2를 비교　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　1. 6과 1을 비교

![병합 정렬 003](https://user-images.githubusercontent.com/76759852/213846385-b93daec6-d262-4aee-9123-7737d2be9636.jpeg)

<br />

2. 3과 4를 비교　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　2. 6과 5를 비교

![병합 정렬 004](https://user-images.githubusercontent.com/76759852/213846386-54ad11d2-e8c6-4fcf-ab21-5511a8463796.jpeg)

<br />

3. 7과 4를 비교　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　3. 나머지 순서대로 넣기

![병합 정렬 005](https://user-images.githubusercontent.com/76759852/213846387-76a28318-c500-4c25-bf57-8cc8e4e6b39d.jpeg)

<br />

![병합 정렬](https://user-images.githubusercontent.com/76759852/213496454-ec41c677-7fe3-4fbd-8d35-c0bcfd000fa8.gif)

### 시간 복잡도

- 둘로 쪼갠 횟수만큼 n번의 루프를 돎으로 $O(nlogn)$
    - 각 $k$(병합 단계) 마다 분할된 배열의 개수를 $n$이라 하면, $2^k$ (k = 1, 2, 3, ...)씩 늘어남
    - 따라서 순환 호출의 깊이가 3 이고, 이를 일반화하면 $n = 2^k$ 의 경우 $k = logn$
    - 순환 호출 횟수(병합 단계)는 $logn$ 번이고 요소의 개수가 $n$ 개 이므로 시간 복잡도는 $O(nlogn)$

### 공간 복잡도

- 병합할 곳의 새로운 배열을 생성해줘야 하는데, 정렬할 배열과 같은 크기(n)의 새로운 배열이 필요하므로 공간복잡도는 $O(2n)$

### 장점

- $O(nlogn)$ 으로 빠름
- 항상 두 부분 리스트로 쪼개어 들어가기 때문에 최악의 경우에도 $O(nlogn)$ 으로 유지됨
- 서로 떨어져 있는 게 아닌 연속된 데이터를 교환하므로 **안정 정렬 (Stable Sort)**

### 단점

- 임시로 결과를 저장하는 배열이 따로 필요하기 때문에 메모리 자원 측면에서 비효율적
- 임시 배열에서 원본 배열로 복사하는 과정이 있기 때문에 데이터가 많을 경우 시간이 많이 소요됨

### 코드

- **Top - Down 방식**

```java
private static int[] sorted; // 합치는 과정에서 정렬하여 원소를 담을 임시배열

public static void mergeSort(int[] a) {

    sorted = new int[a.length];
    mergeSort(a, 0, a.length - 1);
    sorted = null;

}

// Top - Down 방식 구현
private static void mergeSort(int[] a, int left, int right) {

    /*
     * left == right
     * 즉, 부분 리스트가 1개의 원소만 갖고 있는 경우
     * 더이상 쪼갤 수 없으므로 return 한다.
     */
    if (left == right) return;

    int mid = (left + right) / 2; // 절반 위치 

    mergeSort(a, left, mid); // 절반 중 왼쪽 부분 리스트 (left ~ mid)
    mergeSort(a, mid + 1, right); // 절반 중 오른쪽 부분 리스트 (mid+1 ~ right)

    merge(a, left, mid, right); // 병합 작업

}

/**
 * 합칠 부분 리스트는 a배열의 left ~ right 까지 이다.
 *
 * @param a     정렬할 배열
 * @param left  배열의 시작점
 * @param mid   배열의 중간점
 * @param right 배열의 끝점
 */
private static void merge(int[] a, int left, int mid, int right) {

    int l = left; // 왼쪽 부분 리스트 시작점
    int r = mid + 1; // 오른쪽 부분 리스트의 시작점 
    int idx = left; // 채워 넣을 배열의 인덱스

    while (l <= mid && r <= right) {
        /*
         * 왼쪽 부분 리스트 l번째 원소가 오른쪽 부분 리스트 r번째 원소보다 작거나 같을 경우
         * 왼쪽의 l번째 원소를 새 배열에 넣고 l 과 idx 를 1 증가시킨다.
         */
        if (a[l] <= a[r]) {
            sorted[idx] = a[l];
            idx++;
            l++;
        }
        /*
         * 오른쪽 부분 리스트 r번째 원소가 왼쪽 부분 리스트 l번째 원소보다 작거나 같을 경우
         * 오른쪽의 r번째 원소를 새 배열에 넣고 r 과 idx 를 1 증가시킨다.
         */
        else {
            sorted[idx] = a[r];
            idx++;
            r++;
        }
    }

    /*
     * 왼쪽 부분 리스트가 먼저 모두 새 배열에 채워졌을 경우 (l > mid)
     * = 오른쪽 부분 리스트 원소가 아직 남아 있을 경우
     * 오른쪽 부분 리스트의 나머지 원소들을 새 배열에 채워준다.
     */
    if (l > mid) {
        while (r <= right) {
            sorted[idx] = a[r];
            idx++;
            r++;
        }
    }

    /*
     * 오른쪽 부분 리스트가 먼저 모두 새 배열에 채워졌을 경우 (r > right)
     * = 왼쪽 부분 리스트 원소가 아직 남아 있을 경우
     * 왼쪽 부분 리스트의 나머지 원소들을 새 배열에 채워준다.
     */
    else {
        while (l <= mid) {
            sorted[idx] = a[l];
            idx++;
            l++;
        }
    }

    /*
     * 정렬된 새 배열을 기존의 배열에 복사하여 옮겨준다.
     */
    for (int i = left; i <= right; i++) {
        a[i] = sorted[i];
    }

}
```

- **Bottom - Up 방식**

```java
private static int[] sorted; // 합치는 과정에서 정렬하여 원소를 담을 임시 배열

public static void mergeSort(int[] a) {

    sorted = new int[a.length];
    mergeSort(a, 0, a.length - 1);
    sorted = null;
}

// Bottom - Up 방식 구현
private static void mergeSort(int[] a, int left, int right) {

    /*
     * 1 - 2 - 4 - 8 - ... 식으로 1부터 부분 리스트를 나누는 기준을 두 배씩 늘린다.
     */
    for (int size = 1; size <= right; size += size) {

        /*
         * 두 부분 리스트을 순서대로 병합해준다.
         * 예를 들어 현재 부분 리스트의 크기가 1(size = 1)일 때
         * 왼쪽 부분 리스트(low ~ mid)와 오른쪽 부분 리스트(mid + 1 ~ high)를 생각하면
         * 왼쪽 부분 리스트는 low = mid = 0 이고,
         * 오른쪽 부분 리스트는 mid + 1부터 low + (2 * size) - 1 = 1 이 된다.
         *
         * 이 때 high 가 배열의 인덱스를 넘어갈 수 있으므로 right 와 둘 중 작은 값이
         * 병합되도록 해야한다.
         */
        for (int l = 0; l <= right - size; l += (2 * size)) {
            int low = l;
            int mid = l + size - 1;
            int high = Math.min(l + (2 * size) - 1, right);
            merge(a, low, mid, high); // 병합 작업
        }
    }

}

/**
 * 합칠 부분 리스트는 a 배열의 left ~ right 까지 이다.
 *
 * @param a     정렬할 배열
 * @param left  배열의 시작점
 * @param mid   배열의 중간점
 * @param right 배열의 끝점
 */
private static void merge(int[] a, int left, int mid, int right) {
    int l = left; // 왼쪽 부분 리스트 시작점
    int r = mid + 1; // 오른쪽 부분 리스트의 시작점
    int idx = left; // 채워 넣을 배열의 인덱스

    while (l <= mid && r <= right) {
        /*
         * 왼쪽 부분 리스트 l번째 원소가 오른쪽 부분 리스트 r번째 원소보다 작거나 같을 경우
         * 왼쪽의 l번째 원소를 새 배열에 넣고 l 과 idx 를 1 증가시킨다.
         */
        if (a[l] <= a[r]) {
            sorted[idx] = a[l];
            idx++;
            l++;
        }
        /*
         * 오른쪽 부분 리스트 r번째 원소가 왼쪽 부분 리스트 l번째 원소보다 작거나 같을 경우
         * 오른쪽의 r번째 원소를 새 배열에 넣고 r 과 idx 를 1 증가시킨다.
         */
        else {
            sorted[idx] = a[r];
            idx++;
            r++;
        }
    }

    /*
     * 왼쪽 부분 리스트가 먼저 모두 새 배열에 채워졌을 경우 (l > mid)
     * = 오른쪽 부분 리스트 원소가 아직 남아 있을 경우
     * 오른쪽 부분 리스트의 나머지 원소들을 새 배열에 채워준다.
     */
    if (l > mid) {
        while (r <= right) {
            sorted[idx] = a[r];
            idx++;
            r++;
        }
    }

    /*
     * 오른쪽 부분 리스트가 먼저 모두 새 배열에 채워졌을 경우 (r > right)
     * = 왼쪽 부분 리스트 원소가 아직 남아 있을 경우
     * 왼쪽 부분 리스트의 나머지 원소들을 새 배열에 채워준다.
     */
    else {
        while (l <= mid) {
            sorted[idx] = a[l];
            idx++;
            l++;
        }
    }

    /*
     * 정렬된 새 배열을 기존의 배열에 복사하여 옮겨준다.
     */
    for (int i = left; i <= right; i++) {
        a[i] = sorted[i];
    }

}
```

<br />

## 퀵 정렬 (Quick Sort)

> 하나의 리스트를 피벗(pivot)을 기준으로 두 개의 부분 리스트로 나누어 하나는 피벗보다 작은 값들의 부분 리스트, 다른 하나는 피벗보다 큰 값들의 부분 리스트로 정렬한 다음 각 부분 리스트에 대해 다시 재귀적으로 수행하며 정렬하는 알고리즘
> 

### 개념

- **‘분할 정복 (Divide and Conquer)’** 알고리즘을 기반으로 정렬
    - **병합 정렬(Merge Sort)**과 다른 점
        - 병합 정렬의 경우 하나의 리스트를 **‘절반’**으로 나누어 분할 정복을 하기 때문에 **균등**하게 나뉨
        - 퀵 정렬의 경우 피벗(pivot)의 값에 따라 피벗보다 작은 값을 갖는 부분 리스트와 피벗보다 큰 값을 갖는 부분 리스트의 크기가 다를 수 있기 때문에 하나의 리스트에 대해 **비균등**하게 나뉨
- 데이터를 비교하면서 찾는 **'비교 정렬'**
- 정렬의 대상이 되는 데이터 외에 추가적인 공간을 필요로 하지 않으므로 **'제자리 정렬(In-place Sort)'**
- 퀵 정렬은 병합 정렬과는 다르게 하나의 피벗을 두고 두 개의 부분 리스트를 만들 때 서로 떨어진 원소끼리 교환이 일어나기 때문에 **불안정 정렬(Unstable Sort)**

### 과정

1. 리스트 안에 있는 한 요소, **피벗(Pivot)** 을 선택
2. **분할 (Divide)** : 입력 배열을 피벗을 기준으로 비균등하게 2개의 부분 배열로 분할
    - 피벗을 중심으로 왼쪽 : 피벗보다 작은 요소들
    - 피벗을 중심으로 오른쪽 : 피벗보다 큰 요소들
3. **정복 (Conquer)** : 부분 배열을 정렬함
    - 부분 배열의 크기가 충분히 작지 않으면(해당 부분 리스트의 길이가 1이 아니면) 순환 호출을 이용하여 다시 분할 정복 방법을 적용
4. **결합 (Combine)** : 정렬된 부분 배열들을 하나의 배열에 합병

→ 순환 호출이 한 번 진행될 때마다 최소한 하나의 원소(**피벗**)는 최종적으로 위치가 정해지므로, 이 알고리즘은 반드시 끝난다는 것이 보장됨

### 예시

![퀵 정렬](https://user-images.githubusercontent.com/76759852/213846695-f3108fbe-6f60-4865-9684-f33ce481bb74.png)

- 피벗 값을 입력 리스트의 첫 번째 데이터로 함 (다른 임의의 값이어도 상관없음)
- 2개의 인덱스 변수(low, high)를 이용해서 리스트를 두 개의 부분 리스트로 나눈다.
- 1회전 : 피벗이 5인 경우
    - low는 왼쪽에서 오른쪽으로 탐색해가다가 피벗보다 큰 데이터(8)을 찾으면 멈춤
    - high는 오른쪽에서 왼쪽으로 탐색해가다가 피벗보다 작은 데이터(2)를 찾으면 멈춤
    - low와 high가 가리키는 두 데이터를 서로 교환
    - 이 탐색 - 교환 과정은 low와 high가 엇갈릴 때까지 반복
- 2회전 : 피벗(1회전의 왼쪽 부분 리스트의 첫 번째 데이터)이 1인 경우
    - 위와 동일한 방법으로 반복
- 3회전 : 피벗(1회전의 오른쪽 부분 리스트의 첫 번째 데이터)이 9인 경우
    - 위와 동일한 방법으로 반복

![퀵 정렬](https://user-images.githubusercontent.com/76759852/213846663-cf154fc9-f188-497b-9cfd-37b5a39a4c05.gif)

### 시간 복잡도

- **최선의 경우 : $O(nlogn)$**
    
    ![퀵 정렬 (최선)](https://user-images.githubusercontent.com/76759852/213846738-59110ca7-6ec9-48eb-b94e-09deb18730b6.png)
    
    - 비교 횟수 : $logn$
        - 레코드의 개수 n이 2의 거듭제곱이라고 가정($n = 2^k$) 했을 때, $n = 2^3$ 의 경우, $2^3$ → $2^2$ → $2^1$ → $2^0$ 순으로 줄어들어 순환 호출의 깊이가 3임을 알 수 있음
        - 이것을 일반화하면 $n = 2^k$의 경우, $**k = logn**$
    - 각 순환 호출 단계의 비교 연산 : $n$
        - 각 순환 호출에서는 전체 리스트의 대부분의 레코드를 비교해야 하므로 **평균 n번** 정도의 비교가 이루어짐
    
    따라서, 최선의 시간복잡도는 **순환 호출의 깊이 * 각 순환 호출 단계의 비교 연산 = $nlogn$** (이동 횟수는 비교 횟수보다 적으므로 무시할 수 있음)
    
- **최악의 경우 : $O(n^2)$**
    
    → 리스트가 계속 불균형하게 나누어지는 경우, 특히 이미 정렬된 리스트에 대하여 퀵 정렬을 실행 하는 경우
    
    ![퀵 정렬 (최악)](https://user-images.githubusercontent.com/76759852/213846739-6ec72f9e-4d2b-420c-af94-459ee7c03d65.png)
    
    - 비교 횟수 : $n$
        - 레코드의 개수 n이 2의 거듭제곱이라고 가정($n = 2^k$)했을 때, 순환 호출의 깊이는 **n**
    - 각 순환 호출 단계의 비교 연산 : $n$
        - 각 순환 호출에서는 전체 리스트의 대부분의 레코드를 비교해야 하므로 **평균 n번** 정도의 비교가 이루어짐
    
    따라서, 최악의 시간복잡도는 **순환 호출의 깊이 * 각 순환 호출 단계의 비교 연산 = $n^2$** (이동 횟수는 비교 횟수보다 적으므로 무시할 수 있음)
    

- **평균의 경우 : $O(nlogn)$**
    - 시간 복잡도가 $O(nlogn)$ 를 가지는 다른 정렬 알고리즘과 비교했을 때도 가장 빠름
    - 퀵 정렬이 불필요한 데이터의 이동을 줄이고 먼 거리의 데이터를 교환할 뿐만 아니라, 한 번 결정된 피벗들이 추후 연산에서 제외되는 특성 때문

### 공간 복잡도

- 리스트 안에서 Swap 하므로 공간복잡도는 $O(n)$

### 장점

- 불필요한 데이터의 이동을 줄이고 먼 거리의 데이터를 교환할 뿐만 아니라, 한 번 결정된 피벗들이 추후 연산에서 제외되는 특성 때문에, 시간 복잡도가 $O(nlogn)$ 을 가지는 다른 정렬 알고리즘과 비교했을 때도 가장 빠름
- **제자리 정렬 (In-place Sort)** : 추가적인 메모리 공간을 많이 또는 전혀 필요로 하지 않는 알고리즘
    - 정렬하고자 하는 배열 안에서 교환하는 방식이므로 다른 메모리 공간을 필요로 하지 않음

### 단점

- **불안정 정렬(Unstable Sort)**
- 정렬된 배열에 대해서는 퀵 정렬의 **불균형 분할**에 의해 오히려 수행 시간이 더 많이 걸림
    - 퀵 정렬의 불균형 분할을 방지하기 위하여 피벗을 선택할 때 더욱 리스트를 균등하게 분할할 수 있는 데이터를 선택
    → 리스트 내의 몇 개의 데이터 중에서 크기 순으로 중간 값(medium)을 피벗으로 선택한다.

### 코드

- **왼쪽 피벗 선택 방식**

```java
public static void quickSort(int[] a) {

    lPivotSort(a, 0, a.length - 1);

}

/**
 * 왼쪽 피벗 선택 방식
 *
 * @param a  정렬할 배열
 * @param lo 현재 부분 배열의 왼쪽
 * @param hi 현재 부분 배열의 오른쪽
 */
private static void lPivotSort(int[] a, int lo, int hi) {

    /*
     * lo 가 hi 보다 크거나 같다면 정렬 할 원소가
     * 1개 이하이므로 정렬하지 않고 return 한다.
     */
    if (lo >= hi) {
        return;
    }

    /*
     * 피벗을 기준으로 요소들이 왼쪽과 오른쪽으로 약하게 정렬 된 상태로
     * 만들어 준 뒤, 최종적으로 pivot 의 위치를 얻는다.
     *
     * 그리고나서 해당 피벗을 기준으로 왼쪽 부분 리스트와 오른쪽 부분 리스트로 나누어
     * 분할 정복을 해준다.
     *
     * [과정]
     *
     * Partitioning:
     *
     *   a[left]          left part              right part
     * +---------------------------------------------------------+
     * |  pivot  |    element <= pivot    |    element > pivot   |
     * +---------------------------------------------------------+
     *
     *
     *  result After Partitioning:
     *
     *         left part          a[lo]          right part
     * +---------------------------------------------------------+
     * |   element <= pivot    |  pivot  |    element > pivot    |
     * +---------------------------------------------------------+
     *
     *
     *  result : pivot = lo
     *
     *
     *  Recursion:
     *
     * l_pivot_sort(a, lo, pivot - 1)     l_pivot_sort(a, pivot + 1, hi)
     *
     *         left part                           right part
     * +-----------------------+             +-----------------------+
     * |   element <= pivot    |    pivot    |    element > pivot    |
     * +-----------------------+             +-----------------------+
     * lo                pivot - 1        pivot + 1                 hi
     *
     */
    int pivot = partition(a, lo, hi);

    lPivotSort(a, lo, pivot - 1);
    lPivotSort(a, pivot + 1, hi);

}

/**
 * pivot 을 기준으로 파티션을 나누기 위한 약한 정렬 메소드
 *
 * @param a     정렬할 배열
 * @param left  현재 배열의 가장 왼쪽 부분
 * @param right 현재 배열의 가장 오른쪽 부분
 * @return 최종적으로 위치한 피벗의 위치(lo)를 반환
 */
private static int partition(int[] a, int left, int right) {

    int lo = left;
    int hi = right;
    int pivot = a[left]; // 부분 리스트의 왼쪽 요소를 피벗으로 설정

    // lo 가 hi 보다 작을 때 까지만 반복한다.
    while (lo < hi) {

        /*
         * hi 가 lo 보다 크면서
         * hi 의 요소가 pivot 보다 작거나 같은 원소를 찾을 떄 까지
         * hi 를 감소시킨다.
         */
        while (a[hi] > pivot && lo < hi) {
            hi--;
        }

        /*
         * hi 가 lo 보다 크면서
         * lo 의 요소가 pivot 보다 큰 원소를 찾을 떄 까지
         * lo 를 증가시킨다.
         */
        while (a[lo] <= pivot && lo < hi) {
            lo++;
        }

        // 교환될 두 요소를 찾았으면 두 요소를 바꾼다.
        swap(a, lo, hi);
    }

    /*
     * 마지막으로 맨 처음 pivot 으로 설정했던 위치(a[left])의 원소와
     * lo 가 가리키는 원소를 바꾼다.
     */
    swap(a, left, lo);

    // 두 요소가 교환되었다면 피벗이었던 요소는 lo 에 위치하므로 lo 를 반환한다.
    return lo;

}

private static void swap(int[] a, int i, int j) {

    int temp = a[i];
    a[i] = a[j];
    a[j] = temp;

}
```

- **오른쪽 피벗 선택 방식**

```java
public static void quickSort(int[] a) {

    rPivotSort(a, 0, a.length - 1);

}

/**
 * 오른쪽 피벗 선택 방식
 *
 * @param a  정렬할 배열
 * @param lo 현재 부분 배열의 왼쪽
 * @param hi 현재 부분 배열의 오른쪽
 */
private static void rPivotSort(int[] a, int lo, int hi) {

    /*
     * lo가 hi 보다 크거나 같다면 정렬 할 원소가
     * 1개 이하이므로 정렬하지 않고 return 한다.
     */
    if (lo >= hi) {
        return;
    }

    /*
     * 피벗을 기준으로 요소들이 왼쪽과 오른쪽으로 약하게 정렬 된 상태로
     * 만들어 준 뒤, 최종적으로 pivot 의 위치를 얻는다.
     *
     * 그리고나서 해당 피벗을 기준으로 왼쪽 부분리스트와 오른쪽 부분 리스트로 나누어
     * 분할 정복을 해준다.
     *
     * [과정]
     *
     * Partitioning:
     *
     *         left part                right part       a[right]
     * +---------------------------------------------------------+
     * |    element < pivot    |    element >= pivot   |  pivot  |
     * +---------------------------------------------------------+
     *
     *
     *  result After Partitioning:
     *
     *         left part         a[hi]          right part
     * +---------------------------------------------------------+
     * |   element < pivot    |  pivot  |    element >= pivot    |
     * +---------------------------------------------------------+
     *
     *
     *  result : pivot = hi
     *
     *
     *  Recursion:
     *
     * r_pivot_sort(a, lo, pivot - 1)     r_pivot_sort(a, pivot + 1, hi)
     *
     *         left part                           right part
     * +-----------------------+             +-----------------------+
     * |   element <= pivot    |    pivot    |    element > pivot    |
     * +-----------------------+             +-----------------------+
     * lo                pivot - 1        pivot + 1                 hi
     *
     */
    int pivot = partition(a, lo, hi);

    rPivotSort(a, lo, pivot - 1);
    rPivotSort(a, pivot + 1, hi);

}

/**
 * pivot 을 기준으로 파티션을 나누기 위한 약한 정렬 메소드
 *
 * @param a     정렬할 배열
 * @param left  현재 배열의 가장 왼쪽 부분
 * @param right 현재 배열의 가장 오른쪽 부분
 * @return 최종적으로 위치한 피벗의 위치(lo)를 반환
 */
private static int partition(int[] a, int left, int right) {

    int lo = left;
    int hi = right;
    int pivot = a[right]; // 부분 리스트의 오른쪽 요소를 피벗으로 설정

    // lo 가 hi 보다 작을 때 까지만 반복한다.
    while (lo < hi) {

        /*
         * hi 가 lo 보다 크면서, lo의 요소가 pivot 보다 큰 원소를
         * 찾을 떄 까지 lo 를 증가시킨다.
         */
        while (a[lo] < pivot && lo < hi) {
            lo++;
        }

        /*
         * hi가 lo 보다 크면서, hi의 요소가 pivot 보다 작거나 같은 원소를
         * 찾을 떄 까지 hi 를 감소시킨다.
         */
        while (a[hi] >= pivot && lo < hi) {
            hi--;
        }

        // 교환될 두 요소를 찾았으면 두 요소를 바꾼다.
        swap(a, lo, hi);
    }

    /*
     *  마지막으로 맨 처음 pivot 으로 설정했던 위치(a[right])의 원소와
     *  hi 가 가리키는 원소를 바꾼다.
     */
    swap(a, right, hi);

    // 두 요소가 교환되었다면 피벗이었던 요소는 hi 에 위치하므로 hi 를 반환한다.
    return hi;

}

private static void swap(int[] a, int i, int j) {

    int temp = a[i];
    a[i] = a[j];
    a[j] = temp;

}
```

- **중간 피벗 선택 방식**

```java
public static void quickSort(int[] a) {

    mPivotSort(a, 0, a.length - 1);

}

/**
 * 중간 피벗 선택 방식
 *
 * @param a  정렬할 배열
 * @param lo 현재 부분배열의 왼쪽
 * @param hi 현재 부분배열의 오른쪽
 */
private static void mPivotSort(int[] a, int lo, int hi) {

    /*
     *  lo가 hi 보다 크거나 같다면 정렬 할 원소가
     *  1개 이하이므로 정렬하지 않고 return 한다.
     */
    if (lo >= hi) {
        return;
    }

    /*
     * 피벗을 기준으로 요소들이 왼쪽과 오른쪽으로 약하게 정렬 된 상태로
     * 만들어 준 뒤, 최종적으로 pivot 의 위치를 얻는다.
     *
     * 그리고나서 해당 피벗을 기준으로 왼쪽 부분 리스트와 오른쪽 부분 리스트로 나누어
     * 분할 정복을 해준다.
     *
     * [과정]
     *
     * Partitioning:
     *
     *      left part      a[(right + left)/2]      right part
     * +---------------------------------------------------------+
     * |    element < pivot    |  pivot  |    element >= pivot   |
     * +---------------------------------------------------------+
     *
     *
     *  result After Partitioning:
     *
     *         left part         a[hi]          right part
     * +---------------------------------------------------------+
     * |   element < pivot    |  pivot  |    element >= pivot    |
     * +---------------------------------------------------------+
     *
     *
     *  result : pivot = hi
     *
     *
     *  Recursion:
     *
     * m_pivot_sort(a, lo, pivot)         m_pivot_sort(a, pivot + 1, hi)
     *
     *         left part                           right part
     * +-----------------------+             +-----------------------+
     * |   element <= pivot    |             |    element > pivot    |
     * +-----------------------+             +-----------------------+
     * lo                pivot          pivot + 1                   hi
     *
     */
    int pivot = partition(a, lo, hi);

    mPivotSort(a, lo, pivot);
    mPivotSort(a, pivot + 1, hi);

}

/**
 * pivot 을 기준으로 파티션을 나누기 위한 약한 정렬 메소드
 *
 * @param a     정렬할 배열
 * @param left  현재 배열의 가장 왼쪽 부분
 * @param right 현재 배열의 가장 오른쪽 부분
 * @return 최종적으로 위치한 피벗의 위치(hi)를 반환
 */
private static int partition(int[] a, int left, int right) {

    // lo 와 hi 는 각각 배열의 끝에서 1 벗어난 위치부터 시작한다.
    int lo = left - 1;
    int hi = right + 1;
    int pivot = a[(left + right) / 2]; // 부분 리스트의 중간 요소를 피벗으로 설정

    while (true) {

        /*
         * 1 증가시키고 난 뒤의 lo 위치의 요소가 pivot 보다 큰 요소를
         * 찾을 떄 까지 반복한다.
         */
        do {
            lo++;
        } while (a[lo] < pivot);

        /*
         * 1 감소시키고 난 뒤의 hi 위치가 lo 보다 크거나 같은 위치이면서
         * hi 위치의 요소가 pivot 보다 작은 요소를 찾을 떄 까지 반복한다.
         */
        do {
            hi--;
        } while (a[hi] > pivot && lo <= hi);

        /*
         * 만약 hi 가 lo 보다 크지 않다면(엇갈린다면) swap 하지 않고 hi 를 리턴한다.
         */
        if (lo >= hi) {
            return hi;
        }

        // 교환될 두 요소를 찾았으면 두 요소를 바꾼다.
        swap(a, lo, hi);
    }

}

private static void swap(int[] a, int i, int j) {

    int temp = a[i];
    a[i] = a[j];
    a[j] = temp;

}
```

<br />

## 힙 정렬 (Heap Sort)

> 최대 힙 트리나 최소 힙 트리를 구성해 정렬하는 알고리즘
> 

### 개념

- **내림차순** 정렬을 위해서는 **최대 힙**을 구성하고 **오름차순** 정렬을 위해서는 **최소 힙**을 구성
- 삽입보다는 **삭제 과정**만 이루어진다고 생각
- 최대 힙을 구현한 뒤 **루트 노드**를 삭제하여 배열의 맨 마지막에 넣어주고, **깨진 힙을 재구조화**
하는 과정을 반복
- **불안정 정렬**

### 과정

1. 정렬해야 할 n개의 요소들로 **최대 힙(완전 이진 트리 형태)**을 만듦 → **내림차순** 정렬
2. 현재 힙의 루트에는 최댓값이 존재하므로 루트의 값을 마지막 요소와 바꾼 후 힙의 사이즈 하나 줄임
3. 힙의 사이즈가 1 보다 크면 위 과정 반복

### 내림차순 정렬을 위한 최대 힙 구현

- 힙(heap)은 1차원 배열로 쉽게 구현될 수 있음
- 정렬해야 할 n개의 요소들을 1차원 배열에 기억한 후 최대 힙 삽입을 통해 차례대로 삽입
- 최대 힙으로 구성된 배열에서 최댓값부터 삭제

1. **최대 힙(Max Heap)의 삽입**
    - 힙에 새로운 요소가 들어오면 새로운 노드를 힙의 마지막 노드에 이어서 삽입
    - 새로운 노드를 부모 노드들과 교환해서 힙의 성질을 만족시킴

1. **최대 힙(Max Heap)의 삭제**
    - 최대 힙에서 최댓값은 루트 노드이므로 루트 노드가 삭제됨
    - 최대 힙(max heap)에서 삭제 연산은 최댓값을 가진 요소를 삭제하는 것
    - 삭제된 루트 노드에는 힙의 마지막 노드를 가져옴
    - 힙을 재구성

### 예시

![힙 정렬](https://user-images.githubusercontent.com/76759852/213846744-e5b35dd3-d679-4f10-8128-d0e73b88d078.png)

![힙 정렬](https://user-images.githubusercontent.com/76759852/213846811-7568599e-7474-46a9-b319-862824e691c5.gif)

![힙](https://user-images.githubusercontent.com/76759852/213846814-c1c1577d-6765-4348-8515-81740c0bed22.gif)

### 시간 복잡도

- $O(nlogn)$
    - 힙 트리는 완전 이진 트리이므로 전체 높이가 $logn$
    - 그러므로 하나의 요소를 힙에 삽입하거나 삭제할 때 힙을 재정비하는 시간이 $O(logn)$ 만큼 소요됨
    - 요소의 개수가 $n$ 개 이므로 전체적으로 $O(nlogn)$ 의 시간이 걸림

### 공간 복잡도

- 리스트 안에서 Swap 하므로 공간복잡도는 $O(n)$

### 장점

- 최악의 경우에도 $**O(nlogn)**$ 으로 유지됨
- 힙의 특징상 부분 정렬을 할 때 효과가 좋음
    - 전체 자료를 정렬하는 것이 아니라 가장 크거나 가장 작은 값을 구할 때, 최대 k 만큼 떨어진 요소들을 정렬할 때 유용함
- **제자리 정렬 (In-place Sort)** : 추가적인 메모리 공간을 많이 또는 전혀 필요로 하지 않는 알고리즘
    - 정렬하고자 하는 배열 안에서 교환하는 방식이므로 다른 메모리 공간을 필요로 하지 않음

### 단점

- 일반적인 $**O(nlogn)**$ 정렬 알고리즘에 비해 성능은 약간 떨어짐
- 한 번 최대 힙을 만들면서 불안정 정렬 상태에서 최댓값만 갖고 정렬을 하기 때문에 안정 정렬이 아님

### 코드

- **재귀 방식**

```java
public static void heapSort(int[] a) {

    heapSort(a, a.length);

}

private static void heapSort(int[] a, int size) {

    /*
     * 부모 노드와 heaify 과정에서 음수가 발생하면 잘못 된 참조가 발생하기 때문에
     * 원소가 1개 이거나 0개일 경우는 정렬 할 필요가 없으므로 바로 함수를 종료한다.
     */
    if (size < 2) {
        return;
    }

    /*
     * left child node = index * 2 + 1
     * right child node = index * 2 + 2
     * parent node = (index - 1) / 2
     */

    // 가장 마지막 요소의 부모 인덱스 
    int parentIdx = getParent(size - 1);

    // max heap
    for (int i = parentIdx; i >= 0; i--) {
        heapify(a, i, size - 1);
    }

    for (int i = size - 1; i > 0; i--) {

        /*
         * root 인 0번째 인덱스와 i 번째 인덱스의 값을 교환해준 뒤
         * 0 ~ (i - 1) 까지의 부분 트리에 대해 max heap 을 만족하도록
         * 재구성 한다.
         */
        swap(a, 0, i);
        heapify(a, 0, i - 1);
    }

}

// 부모 인덱스를 얻는 함수
private static int getParent(int child) {

    return (child - 1) / 2;

}

// 두 인덱스의 원소를 교환하는 함수
private static void swap(int[] a, int i, int j) {

    int temp = a[i];
    a[i] = a[j];
    a[j] = temp;

}

// 힙을 재구성 하는 함수
private static void heapify(int[] a, int parentIdx, int lastIdx) {

    /*
     * 현재 트리에서 부모 노드의 자식 노드 인덱스를 각각 구해준다.
     * 현재 부모 인덱스를 가장 큰 값을 갖고 있다고 가정한다.
     */
    int leftChildIdx = 2 * parentIdx + 1;
    int rightChildIdx = 2 * parentIdx + 2;
    int largestIdx = parentIdx;

    /*
     * left child node 와 비교
     *
     * 자식 노드 인덱스가 트리의 크기를 넘어가지 않으면서
     * 현재 가장 큰 인덱스보다 왼쪽 자식 노드의 값이 더 클 경우
     * 가장 큰 인덱스를 가리키는 largestIdx 를 왼쪽 자식 노드 인덱스로 바꿔준다.
     *
     */
    if (leftChildIdx <= lastIdx && a[largestIdx] < a[leftChildIdx]) {
        largestIdx = leftChildIdx;
    }

    /*
     * right child node 와 비교
     *
     * 자식 노드 인덱스가 트리의 크기를 넘어가지 않으면서
     * 현재 가장 큰 인덱스보다 오른쪽 자식 노드의 값이 더 클 경우
     * 가장 큰 인덱스를 가리키는 largestIdx 를 오른쪽 자식 노드 인덱스로 바꿔준다.
     *
     */
    if (rightChildIdx <= lastIdx && a[largestIdx] < a[rightChildIdx]) {
        largestIdx = rightChildIdx;
    }

    /*
     * largestIdx 와 부모 노드가 같지 않다는 것은
     * 위 자식 노드 비교 과정에서 현재 부모 노드보다 큰 노드가 존재한다는 뜻이다.
     * 그럴 경우 해당 자식 노드와 부모 노드를 교환해주고,
     * 교환 된 자식 노드를 부모 노드로 삼은 서브 트리를 검사하도록 재귀 호출 한다.
     */
    if (parentIdx != largestIdx) {
        swap(a, largestIdx, parentIdx);
        heapify(a, largestIdx, lastIdx);
    }

}
```

- **반복문 방식**

```java
public static void heapSort(int[] a) {

    heapSort(a, a.length);

}

private static void heapSort(int[] a, int size) {

    /*
     * 부모 노드와 heaify 과정에서 음수가 발생하면 잘못 된 참조가 발생하기 때문에
     * 원소가 1개 이거나 0개일 경우는 정렬 할 필요가 없으므로 바로 함수를 종료한다.
     */
    if (size < 2) {
        return;
    }

    /*
     * left child node = index * 2 + 1
     * right child node = index * 2 + 2
     * parent node = (index - 1) / 2
     */

    // 가장 마지막 요소의 부모 인덱스 
    int parentIdx = getParent(size - 1);

    // max heap
    for (int i = parentIdx; i >= 0; i--) {
        heapify(a, i, size - 1);
    }

    for (int i = size - 1; i > 0; i--) {

        /*
         * root 인 0번째 인덱스와 i번째 인덱스의 값을 교환해준 뒤
         * 0 ~ (i - 1) 까지의 부분 트리에 대해 max heap을 만족하도록
         * 재구성 한다.
         */
        swap(a, 0, i);
        heapify(a, 0, i - 1);
    }

}

// 부모 인덱스를 얻는 함수
private static int getParent(int child) {

    return (child - 1) / 2;

}

// 두 인덱스의 원소를 교환하는 함수
private static void swap(int[] a, int i, int j) {

    int temp = a[i];
    a[i] = a[j];
    a[j] = temp;

}

private static void heapify(int[] a, int parentIdx, int lastIdx) {

    int leftChildIdx;
    int rightChildIdx;
    int largestIdx;

    /*
     * 현재 부모 인덱스의 자식 노드 인덱스가
     * 마지막 인덱스를 넘지 않을 때 까지 반복한다.
     *
     * 이 때 왼쪽 자식 노드를 기준으로 해야 한다.
     * 오른쪽 자식 노드를 기준으로 범위를 검사하게 되면
     * 마지막 부모 인덱스가 왼쪽 자식만 갖고 있을 경우
     * 왼쪽 자식 노드와는 비교 및 교환을 할 수 없기 때문이다.
     */
    while ((parentIdx * 2) + 1 <= lastIdx) {
        leftChildIdx = (parentIdx * 2) + 1;
        rightChildIdx = (parentIdx * 2) + 2;
        largestIdx = parentIdx;

        /*
         * left child node 와 비교
         * (범위는 while 문에서 검사했으므로 별도 검사 필요 없음)
         */
        if (a[leftChildIdx] > a[largestIdx]) {
            largestIdx = leftChildIdx;
        }

        /*
         * right child node 와 비교
         * right child node 는 범위를 검사해주어야 한다.
         */
        if (rightChildIdx <= lastIdx && a[rightChildIdx] > a[largestIdx]) {
            largestIdx = rightChildIdx;
        }

        /*
         * 교환이 발생했을 경우 두 원소를 교체 한 후
         * 교환이 된 자식 노드를 부모 노드가 되도록 교체한다.
         */
        if (largestIdx != parentIdx) {
            swap(a, parentIdx, largestIdx);
            parentIdx = largestIdx;
        } else {
            return;
        }
    }

}
```
