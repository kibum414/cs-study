# TDD 란 ?

TDD 란 **Test Driven Development** 의 약자로 **테스트 주도 개발** 이라 하며, **켄트 벡(Kent Beck)** 에 의해 고안되었다.

<br />

TDD 는 반복 테스트를 이용한 소프트웨어 방법론으로, 요구사항에 따른 작은 단위의 테스트 케이스를 설정하고, 이를 통과할 수 있는 코드를 작성한 뒤, 해당 코드를 리팩토링하는 과정를 반복하며 프로그래밍을 진행하는 방법이다.

<br />

```
😎 TDD = TFD(Test First Development) + Refactoring
```

<br />

TDD 는 **TFD(Test First Development)** 와 **리팩토링** 이 더해진 구조로, 테스트를 먼저 작성하고 계속적으로 리팩토링을 진행하면서 코드를 보다 나은 방향으로 수정하는 의미가 담겨 있다고 볼 수 있다.

기존 테스트 코드 작성은 프로덕션 코드가 작성된 이후에 이루어졌지만, TDD를 적용하면 프로덕션 코드보다 실패하는 테스트 코드를 먼저 작성하고, 코드를 테스트를 통과하기 위해 최소한으로 개선한다. 이후 테스트를 통과한 프로덕션 코드를 리팩토링 한다.

TDD 를 이용하면 모든 요구사항(목표)에 대해 점검할 수 있으며, 사용자 입장에서 코드를 작성할 수 있다. 구현 보다는 인터페이스에 조금 더 집중해서 코드를 작성할 수 있어 코드의 퀄리티가 향상되고 시스템의 전반적인 설계를 향상할 수 있다.

<br />

짧은 개발 주기의 반복에 의존하는 개발 프로세스이며, 애자일 방법론 중 하나인 **eXtream Programming(XP)** 의 **‘Test First’** 개념에 기반을 둔 단순한 설계를 중요시한다.

> **eXtream Programming(XP)**
>
> 미래에 대한 예측을 최대한 하지 않고, 지속적으로 프로토타입을 완성하는 애자일 방법론 중 하나이다.<br />
> 추가 요구사항이 생기더라도 실시간으로 반영할 수 있다.

<br /><br /><br />

## TDD 개발 주기

![TDD](https://user-images.githubusercontent.com/76759852/213872605-f98042b5-367b-4c63-9d14-69668731f771.png)

### **Red** 단계 : **실패하는 테스트 코드** 작성

앞으로 작성될 프로덕션 코드가 어떤 동작을 하면 좋을지 적는다. 테스트 코드를 먼저 작성하기 때문에 테스트 코드가 기대하는 로직이 실행되지 않아 테스트는 실패할 것이다.

핵심은 실패하는 테스트 코드를 작성하는 것, 즉 **RED** 를 띄우는 것이다.

```java
@Test
void multiplyTest() {

    // given
    Calculator calculator = new Calculator();

    // when
    int result = calculator.multiply(3, 7);

    // then
    assertThat(result).isEqualTo(21);

}
```

`Calculator` 클래스를 작성하지 않았기 때문에 이 테스트 코드는 무조건 실패한다.

<br />

### **Green** 단계 : 테스트 코드를 **성공시키기 위한 실제 코드** 작성

방금 작성한 실패하는 테스트 코드를 통과하도록 만드는 최소한의 코드를 작성한다. 가장 빠르게 **GREEN** 을 보는 것이 우선이다. 

빠르게 구현할 수 있는 깔끔한 코드가 있다면 바로 작성하면 되지만, 오래 걸릴 것 같다면 일단 테스트 코드를 통과하는 데에만 집중하여 코드를 작성한다. 켄트 벡은 이를 죄악이라고 표현한다.

GREEN 을 보기 위해서는 어떤 죄악을 저질러도 상관없다.

```java
public class Calculator {

    public int multiply(int a, int b) {
        return a * b;
    }

}
```

이 테스트 코드는 실제 곱하기 연산을 수행하지 않지만, `multiplyTest` 를 통과하는 프로덕션 코드이다.

<br />

### **Blue** 단계 : 중복 코드 제거, 일반화 등의 **리팩토링** 수행

```java
public class Calculator {

    public int multiply(int a, int b) {
        return a * b;
    }

}
```

테스트만 통과하기 위한 코드를 리팩토링한 코드이다.

<br /><br /><br />

## TDD 의 원칙

1. 실패하는 단위 테스트 코드를 작성할 때까지 프로덕션 코드를 작성하지 않는다.
2. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트 코드를 작성한다.
3. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.

이를 통해, 실제 코드에 대해 기대되는 바를 보다 명확하게 정의함으로써 <u>불필요한 설계를 피할 수 있고, 정확한 요구 사항에 집중할 수 있다.</u>

<br /><br /><br />

## 일반 개발 방식 vs TDD 개발 방식

### 일반적인 개발 방식

![기존 프로세스](https://user-images.githubusercontent.com/76759852/213872617-1d72a179-3c65-4992-a947-a9b6d3ad4633.png)

**요구사항 분석 → 설계 → 개발 → 테스트 → 배포** 형태의 개발 주기를 가진다.

이러한 방식은 아래와 같은 이유로 소프트웨어 개발을 느리게 하는 잠재적 위험이 존재한다.

1. 소비자의 요구사항이 처음부터 명확하지 않을 수 있다.
2. 따라서 처음부터 완벽한 설계는 어렵다.
3. 자체 버그 검출 능력 저하 또는 소스코드의 품질이 저하될 수 있다.
4. 자체 테스트 비용이 증가할 수 있다.

이러한 문제점들이 발생되는 이유는 어느 프로젝트든 초기 설계가 완벽하다고 말할 수 없기 때문이다. 고객의 요구사항이나 디자인의 오류 등 많은 외부 또는 내부 조건에 의해 재설계하여 점진적으로 완벽한 설계로 나아가는데, 재설계로 인해 개발자는 코드를 삽입, 수정, 삭제하는 과정에서 불필요한 코드가 남거나 중복 처리될 가능성이 크다.

또한 작은 부분의 기능 수정에도 모든 부분을 테스트해야 하므로 자체 테스트 비용이 증가되고 전체적인 버그를 검출하기 어려워진다.

결론적으로 이러한 코드들은 재사용이 어렵고 관리가 어려워져 유지보수를 어렵게 만든다.

<br />

### TDD

![TDD 프로세스](https://user-images.githubusercontent.com/76759852/213872621-0c030fb0-8508-44ae-9fc7-32dd4e4d7212.png)

**테스트 → 테스트 실패 시 버그 수정 → 테스트 → 성공 → 리팩토링** 형태의 개발 주기를 가진다.

TDD와 일반적인 개발 방식의 가장 큰 차이점은 **테스트 코드를 작성한 뒤에 실제 코드를 작성**한다는 점이다.

디자인(설계) 단계에서 프로그래밍 목적을 반드시 정의해야만 하고, 무엇을 테스트해야 할지 미리 정의(테스트 케이스 작성)해야만 한다.

테스트 코드를 작성하는 도중에 발생하는 예외사항(버그, 수정사항)들은 테스트 케이스에 추가하고 설계를 개선한다. 이후 테스트가 통과된 코드만을 코드 개발 단계에서 실제 코드로 작성한다.

이러한 반복적인 단계가 진행되면서 자연스럽게 코드의 버그가 줄어들고 소스코드는 간결해지며, 테스트 케이스 작성으로 인해 자연스럽게 설계가 개선됨으로서 재설계 시간이 절감된다.

```
😎 JUnit

TDD 의 대표적인 Tool 로, 전세계적으로 가장 널리 사용되는 Java 단위 테스트 프레임워크 이다.
JUnit 을 시작으로 CUnit(C언어), CppUnit(C++), PyUnit(Python) 등 xUnit 프레임워크가 탄생하게 되었다.
```

<br /><br /><br />

## TDD 의 효과

### 1. 보다 튼튼한 객체 지향적인 코드를 생산할 수 있다.

TDD 는 코드의 재사용 보장을 명시하므로 TDD 를 통한 소프트웨어 개발 시 기능별 철저한 모듈화가 이루어진다. 이는 종속성과 의존성이 낮은 모듈로 조합된 소프트웨어 개발을 가능하게 하며, 필요에 따라 모듈을 추가하거나 제거해도 소프트웨어 전체 구조에 영향을 미치지 않게 된다.

### 2. 재설계 시간을 단축할 수 있다.

테스트 코드를 먼저 작성하기 때문에 개발자가 지금 무엇을 해야 하는지 분명히 정의하고 개발을 시작하게 된다. 또한 테스트 시나리오를 작성하면서 다양한 예외사항에 대해 생각해볼 수 있어 개발 진행 중 소프트웨어의 전반적인 설계가 변경되는 일을 방지할 수 있다.

### 3. 디버깅 시간을 단축할 수 있다.

유닛 테스팅을 하는 이점이기도 한데, 예를 들어 사용자의 데이터가 잘못 나온다면 DB의 문제인지, 비즈니스 레이어의 문제인지, UI의 문제인지 등 실제 모든 레이어들을 전부 디버깅해야 하지만, TDD 의 경우 자동화된 유닛 테스팅을 전제로 하기 때문에 특정 버그를 손쉽게 찾아낼 수 있다.

### 4. 테스트 문서를 대체할 수 있다.

주로 SI 프로젝트 진행 과정에서 어떤 요소들이 테스트 되었는지 테스트 정의서를 만들지만 단순 통합 테스트 문서일 뿐이다. 하지만 TDD 를 하게 될 경우 테스팅을 자동화시킴과 동시에 보다 정확한 테스트 근거를 산출할 수 있다.

### 5. 추가 구현이 용이하다.

개발이 완료된 소프트웨어에 어떤 기능을 추가할 때 가장 우려되는 점은 해당 기능이 기존 코드에 어떤 영향을 미칠지 알지 못한다는 것이다. 하지만 TDD 의 경우 자동화된 유닛 테스팅을 전제하므로 테스트 기간을 획기적으로 단축시킬 수 있다.

<br /><br /><br />

## TDD 의 단점

### 1. 생산성이 저하된다.

테스트 코드의 작성으로 절대적인 코드량이 늘어나고, 기본적인 기능 구현 외에 추가적인 테스트 코드 작성을 해야 하기 때문에 프로젝트 개발 시간이 일반적인 개발 방식에 비해 약 10~30% 정도 늘어나게 된다. 또한 개발이 점차 진행됨에 따라 비례하여 증가하는 테스트 코드들의 관리에 대한 부분도 이슈가 될 수 있다.

따라서 시간적 여유가 없는 프로젝트에서는 TDD 방식을 잘 사용하지 않는다.

<br /><br /><br />

## TDD 를 하기 어려운 이유

### 1. 이제까지 자신이 개발하던 방식을 많이 바꿔야 한다.

몸에 체득한 것이 많을 수록 바꾸기 어렵기 때문에, 오히려 개발을 별로 해보지 않은 사람들에겐 적용하기 쉽다.

### 2. TDD 는 이렇게 해야된다는 이미지 또는 틀이 있다.

‘반드시 툴(단위 테스트 프레임워크)을 써서 개발해야 된다’ 라고 생각하지만, 이러한 규칙에 얽매이는 것은 애자일 방식이 아니다.

결국 규칙에 얽매여 똑같은 테스트를 복붙하는데, 이렇듯 도구나 규칙에 집착하다 보니 TDD 가 어려워지는 것이다.

<br /><br /><br />

## 좋은 테스트 코드를 위한 FIRST 규칙

### Fast

테스트는 빠르게 동작하여 자주 돌릴 수 있어야 한다.

### Independent

각각의 테스트는 독립적이며 서로 의존해서는 안 된다.

→ 테스트에 필요한 데이터는 테스트 내부에서 독립적으로 사용해야 한다. 서로에게 의존할 경우 테스트 하나가 실패할 때 나머지도 잇달아 실패하므로 원인을 진단하기 어려워지기 때문이다.

### Repeatable

어느 환경(네트워크나 데이터베이스에 의존하지 않는 환경)에서도 반복 가능해야 한다.

→ 환경에 의존하지 않는 테스트가 실패할 수 있는 유일한 이유는 오로지 테스트할 클래스 또는 메소드가 제대로 작동하지 않기 때문이다.

### Self-Validating

테스트는 성공 또는 실패로 boolean 값으로 결과를 내어 자체적으로 검증되어야 한다.

### Timely

테스트는 적시에 즉, 테스트하려는 실제 코드를 구현하기 직전에 구현해야 한다.
